# При создании генератора мы указываем диапазон перебираемых целых
# чисел, но не сохраняем их в памяти. Каждое из значений генерируется на
# очередном витке цикла.
a = range(0, 10, 2)
print(f'{a=}, {type(a)=}, {a.__sizeof__()=}, {len(a)}')
b = range(-1_000_000, 1_000_000, 2)
print(f'{b=}, {type(b)=}, {b.__sizeof__()=}, {len(b)}')

# Для создания генераторного выражения используют круглые скобки, внутри
# которых прописывается логика выражения. В нашем примере циклический перебор
# целых чисел от 97 до 122 и возврат символов из таблицы ASCII с
# соответствующими кодами.

my_gen = (chr(i) for i in range(97, 123))
print(my_gen) # <generator object <genexpr> at0x000001ED58DD7D60>
for char in my_gen:
    print(char)



# Создаём генератор на основе двух списков x и y. 7 элементов в первом списке и 6 во
# втором. Всего 13. Генератор считает сумму пар элементов.
# Генератор перебирает все значения списка x и оставляет только нечётные.
# Исключаем 2 и 8, т.е. оставляем 5 из 7 элементов списка для вычисления суммы. В
# списке y исключаем единицу, т.е. оставляем 5 из 6 элементов. Новичок может
# подумать, что на выходе получим 10 элементов - 5 из x и 5 из y. Но циклы вложены
# друг в друга, следовательно количество элементов на выходе 5х5=25. А
# асимптотика данного генератора квадратичная, O(NхM), где N и M - длина списков x
# и y.

x = [1, 1, 2, 3, 5, 8, 13]
y = [1, 2, 6, 24, 120, 720]
print(f'{len(x)=}\t{len(y)=}')
mult = (i + j for i in x if i % 2 != 0 for j in y if j != 1)
res = list(mult)
print(f'{len(res)=}\n{res}')


